Δεν «πιάνει» γιατί ο κινητήρας snap δεν έχει σημεία. Δύο αιτίες:

Λάθος input στο extractor.
Το extractEndpoints διαβάζει parserResult.entities, που εδώ είναι αριθμός (3262) και όχι array, άρα επιστρέφει 0 σημεία. Το log το δείχνει καθαρά:
⚠️ extractEndpoints: entities is not an array: number → 📍 SnapEngine: Extracted 0 endpoints → ✅ useSnapEngine: Ready with 0 snap points. 

localhost

Ασυμβατότητα συστημάτων συντεταγμένων.
Οι αποστάσεις για snap υπολογίζονται σε pixels καμβά, ενώ τα σημεία που εξάγονται είναι σε τοπικές DXF μονάδες. Ακόμα και αν υπήρχαν σημεία, χωρίς μετασχηματισμό σε canvas-space δεν «κλειδώνει» στα 10px. (Το log δείχνει canvas rendering αλλά καμία ένδειξη επιτυχημένου snap.) 

localhost

Σημείωση: Το binding του snap στο layer ενεργοποιείται μόνον όταν το state γίνει picking-floor. Στο log φαίνεται ότι γίνεται σωστά όταν πατάς “Add Control Point”, άρα το event wiring είναι ΟΚ. 

localhost

Τι να αλλάξεις:

A) Διόρθωσε τον extractor να δουλεύει πάνω στο GeoJSON.

// floor-plan-system/snapping/engine/endpoint-detector.ts
export function extractEndpoints(parserResult: ParserResult | null): SnapPoint[] {
  const feats = parserResult?.geoJSON?.features ?? [];
  const out: SnapPoint[] = [];

  for (const f of feats) {
    const g = f.geometry;
    if (!g) continue;

    if (g.type === 'LineString' && Array.isArray(g.coordinates) && g.coordinates.length >= 2) {
      const coords = g.coordinates as number[][];
      const [x1, y1] = coords[0];
      const [x2, y2] = coords[coords.length - 1];
      out.push({ x: x1, y: y1, mode: SnapMode.Endpoint, label: 'LINE start' });
      out.push({ x: x2, y: y2, mode: SnapMode.Endpoint, label: 'LINE end' });
    }
    // Αν τα ARC/CIRCLE έχουν ήδη μετατραπεί σε LineString από τον parser, καλύπτονται.
  }

  return deduplicateSnapPoints(out);
}


B) Φέρε τα snap points στο ίδιο σύστημα με τον καμβά. Δύο ασφαλείς επιλογές. Επίλεξε μία:

Επιλογή 1: Μετασχημάτισε ΟΛΑ τα snap points σε canvas-space κάθε φορά που αλλάζει το viewport.
Πρόσθεσε στον SnapEngine μέθοδο π.χ. setCanvasTransform({sx, sy, ox, oy}) και αποθήκευε canvasPoints = points.map(p => ({...p, x: p.x*sx + ox, y: p.y*sy + oy})). Κάλεσέ την από το FloorPlanCanvasLayer εκεί που ήδη υπολογίζεις scale/offset πριν το render.

Επιλογή 2: Μετασχημάτισε τον κέρσορα σε DXF-space και μετέτρεψε και το radius σε DXF μονάδες.
Στο handleMouseMove, υπολόγισε:

const localX = (canvasX - offsetX) / scaleX;
const localY = (canvasY - offsetY) / scaleY;
const radiusLocal = 10 / ((scaleX + scaleY) / 2);
snapEngine.calculateSnapLocal(localX, localY, radiusLocal);


και στον engine κάνε τη σύγκριση με τα DXF σημεία.

Γιατί είμαι βέβαιος:
– Πριν το upload: ⚠️ SnapEngine: No parser result provided (αρχική κλήση χωρίς δεδομένα). Μετά το upload: parser OK, αλλά ο extractor γυρνά 0 γιατί κοιτά τον λάθος κόμβο. 

localhost


– Το state picking-floor ανάβει όταν πατάς το κουμπί, άρα τα mouse events δένονται. Το μοναδικό εμπόδιο είναι τα 0 σημεία και το λάθος space. 

localhost

Εφάρμοσε (A) και μία από τις (B1/B2). Θα δεις άμεσα κυανό κύκλο πάνω στα endpoints.