#!/usr/bin/env node

/**
 * ðŸŒ i18n TypeScript Types Generator
 *
 * This script automatically generates TypeScript type definitions
 * for internationalization keys based on the translation files.
 *
 * Features:
 * - Scans all translation files in supported locales
 * - Generates strongly-typed interfaces for i18n keys
 * - Supports nested translation objects
 * - Creates autocomplete-friendly type definitions
 * - Handles missing translation files gracefully
 */

const fs = require('fs');
const path = require('path');

// Configuration
const I18N_DIR = path.join(__dirname, '..', 'src', 'i18n', 'locales');
const TYPES_OUTPUT_DIR = path.join(__dirname, '..', 'src', 'types');
const TYPES_OUTPUT_FILE = path.join(TYPES_OUTPUT_DIR, 'i18n.ts');
const PRIMARY_LOCALE = 'el'; // Greek as primary locale

// Colors for console output
const colors = {
  reset: '\x1b[0m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  magenta: '\x1b[35m',
  cyan: '\x1b[36m'
};

function log(message, color = 'reset') {
  console.log(`${colors[color]}${message}${colors.reset}`);
}

function logSuccess(message) {
  log(`âœ… ${message}`, 'green');
}

function logError(message) {
  log(`âŒ ${message}`, 'red');
}

function logWarning(message) {
  log(`âš ï¸  ${message}`, 'yellow');
}

function logInfo(message) {
  log(`â„¹ï¸  ${message}`, 'cyan');
}

/**
 * Check if i18n directory exists
 */
function checkI18nExists() {
  if (!fs.existsSync(I18N_DIR)) {
    logWarning('i18n directory not found. This is acceptable for projects without i18n.');
    return false;
  }

  const primaryLocalePath = path.join(I18N_DIR, PRIMARY_LOCALE);
  if (!fs.existsSync(primaryLocalePath)) {
    logWarning(`Primary locale '${PRIMARY_LOCALE}' directory not found.`);
    return false;
  }

  return true;
}

/**
 * Get all translation files from primary locale
 */
function getTranslationFiles() {
  const primaryLocalePath = path.join(I18N_DIR, PRIMARY_LOCALE);

  try {
    return fs.readdirSync(primaryLocalePath)
      .filter(file => file.endsWith('.json'))
      .map(file => path.join(primaryLocalePath, file));
  } catch (error) {
    logError(`Error reading primary locale directory: ${error.message}`);
    return [];
  }
}

/**
 * Parse translation file and extract keys
 */
function parseTranslationFile(filePath) {
  try {
    const content = fs.readFileSync(filePath, 'utf8');
    const data = JSON.parse(content);
    const fileName = path.basename(filePath, '.json');
    return { fileName, data, success: true };
  } catch (error) {
    logError(`Error parsing ${filePath}: ${error.message}`);
    return { success: false };
  }
}

/**
 * Generate TypeScript interface from translation object
 */
function generateInterface(obj, interfaceName, indent = 0) {
  const indentStr = '  '.repeat(indent);
  let result = `${indentStr}interface ${interfaceName} {\n`;

  for (const key in obj) {
    if (obj.hasOwnProperty(key)) {
      const value = obj[key];
      const indentStr2 = '  '.repeat(indent + 1);

      if (typeof value === 'object' && value !== null) {
        // Nested object - create sub-interface
        const subInterfaceName = `${interfaceName}_${key.charAt(0).toUpperCase() + key.slice(1)}`;
        result += `${indentStr2}${key}: ${subInterfaceName};\n`;
        result += `}\n\n`;
        result += generateInterface(value, subInterfaceName, indent);
        return result;
      } else {
        // String value
        result += `${indentStr2}${key}: string;\n`;
      }
    }
  }

  result += `${indentStr}}\n`;
  return result;
}

/**
 * Generate complete TypeScript definitions
 */
function generateTypeDefinitions(translationData) {
  let typeDefinitions = `/**
 * ðŸŒ Auto-generated i18n TypeScript Definitions
 *
 * This file is automatically generated from translation files.
 * Do not edit manually - changes will be overwritten.
 *
 * Generated: ${new Date().toISOString()}
 */

`;

  // Generate interfaces for each namespace
  const namespaces = Object.keys(translationData);

  if (namespaces.length === 0) {
    typeDefinitions += `// No translation files found - using minimal interface
export interface I18nKeys {
  [key: string]: string;
}

export type TranslationNamespace = 'common';
`;
  } else {
    // Generate individual namespace interfaces
    namespaces.forEach(namespace => {
      const data = translationData[namespace];
      const interfaceName = `I18n_${namespace.charAt(0).toUpperCase() + namespace.slice(1)}`;
      typeDefinitions += generateInterface(data, interfaceName);
      typeDefinitions += '\n';
    });

    // Generate main interface
    typeDefinitions += 'export interface I18nKeys {\n';
    namespaces.forEach(namespace => {
      const interfaceName = `I18n_${namespace.charAt(0).toUpperCase() + namespace.slice(1)}`;
      typeDefinitions += `  ${namespace}: ${interfaceName};\n`;
    });
    typeDefinitions += '}\n\n';

    // Generate namespace union type
    const namespaceList = namespaces.map(ns => `'${ns}'`).join(' | ');
    typeDefinitions += `export type TranslationNamespace = ${namespaceList};\n\n`;

    // Generate utility types
    typeDefinitions += `/**
 * Utility type for nested translation keys
 */
export type NestedKeyOf<ObjectType extends object> = {
  [Key in keyof ObjectType & (string | number)]: ObjectType[Key] extends object
    ? \`\${Key}.\${NestedKeyOf<ObjectType[Key]>}\`
    : \`\${Key}\`
}[keyof ObjectType & (string | number)];

/**
 * All available translation keys in dot notation
 */
export type TranslationKey = NestedKeyOf<I18nKeys>;
`;
  }

  return typeDefinitions;
}

/**
 * Ensure output directory exists
 */
function ensureOutputDirectory() {
  if (!fs.existsSync(TYPES_OUTPUT_DIR)) {
    fs.mkdirSync(TYPES_OUTPUT_DIR, { recursive: true });
    logInfo(`Created types directory: ${TYPES_OUTPUT_DIR}`);
  }
}

/**
 * Write type definitions to file
 */
function writeTypeDefinitions(content) {
  ensureOutputDirectory();

  try {
    fs.writeFileSync(TYPES_OUTPUT_FILE, content, 'utf8');
    logSuccess(`TypeScript definitions written to: ${TYPES_OUTPUT_FILE}`);
  } catch (error) {
    logError(`Error writing type definitions: ${error.message}`);
    process.exit(1);
  }
}

/**
 * Main generation function
 */
function main() {
  log('\nðŸŒ i18n TypeScript Types Generator', 'cyan');
  log('====================================\n', 'cyan');

  // Check if i18n is implemented
  const hasI18n = checkI18nExists();

  if (!hasI18n) {
    logInfo('i18n not found or incomplete. Generating minimal type definitions.');
    const minimalTypes = generateTypeDefinitions({});
    writeTypeDefinitions(minimalTypes);
    logSuccess('Minimal i18n type definitions generated successfully!');
    return;
  }

  // Load translation files
  const translationFiles = getTranslationFiles();

  if (translationFiles.length === 0) {
    logWarning('No translation files found in primary locale.');
    const minimalTypes = generateTypeDefinitions({});
    writeTypeDefinitions(minimalTypes);
    logSuccess('Minimal i18n type definitions generated successfully!');
    return;
  }

  // Parse all translation files
  const translationData = {};
  let hasErrors = false;

  translationFiles.forEach(filePath => {
    const result = parseTranslationFile(filePath);

    if (result.success) {
      translationData[result.fileName] = result.data;
      logSuccess(`Loaded: ${result.fileName}.json`);
    } else {
      hasErrors = true;
    }
  });

  // Generate type definitions
  if (!hasErrors) {
    const typeDefinitions = generateTypeDefinitions(translationData);
    writeTypeDefinitions(typeDefinitions);

    logSuccess('i18n type definitions generated successfully!');
    log(`Generated interfaces for: ${Object.keys(translationData).join(', ')}`, 'green');
  } else {
    logError('Type generation failed due to parsing errors.');
    process.exit(1);
  }
}

// Run the script
if (require.main === module) {
  main();
}

module.exports = {
  generateTypeDefinitions,
  checkI18nExists,
  parseTranslationFile
};