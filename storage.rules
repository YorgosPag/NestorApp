rules_version = '2';

// =============================================================================
// ğŸ”’ ENTERPRISE FIREBASE STORAGE SECURITY RULES
// =============================================================================
//
// ğŸ¯ Î£Î¤Î¡Î‘Î¤Î—Î“Î™ÎšÎ—: Least privilege - explicit allow per path pattern
// ğŸ›¡ï¸ Î‘Î¡Î§Î—: Authentication required + path-based authorization
// ğŸ“‹ ADR-031: Canonical File Storage System
//
// PATH SCHEME (IDs only, no Greek names):
// /companies/{companyId}/projects/{projectId}/entities/{entityType}/{entityId}/
//   domains/{domain}/categories/{category}/files/{fileId}.{ext}
//
// LEGACY PATHS (temporary backward compatibility):
// /contacts/photos/{filename}
// /floor-plans/{buildingId}/{floorId}/{filename}
//
// =============================================================================

service firebase.storage {
  match /b/{bucket}/o {

    // =========================================================================
    // ğŸ”’ ENTERPRISE SECURITY - NO WILDCARD ALLOW-ALL
    // =========================================================================
    // All access must be granted through specific path rules below
    // Default: DENY (Firebase default behavior)

    // =========================================================================
    // ğŸ” HELPER FUNCTIONS
    // =========================================================================

    // Check if user is authenticated
    function isAuthenticated() {
      return request.auth != null;
    }

    // Check if user owns the resource (by UID in path or metadata)
    function isOwner(userId) {
      return request.auth != null && request.auth.uid == userId;
    }

    // Get user's companyId from custom claims
    function getUserCompanyId() {
      return request.auth.token.companyId;
    }

    // Check if user belongs to the specified company
    function belongsToCompany(companyId) {
      return isAuthenticated() && getUserCompanyId() == companyId;
    }

    // Check if user is internal (has globalRole claim)
    function isInternalUser() {
      return isAuthenticated() &&
             request.auth.token.globalRole in ['super_admin', 'company_admin', 'internal_user'];
    }

    // Check if user is super_admin (system-wide access)
    function isSuperAdmin() {
      return isAuthenticated() && request.auth.token.globalRole == 'super_admin';
    }

    // Validate file size (max 50MB)
    function isValidFileSize() {
      return request.resource.size < 50 * 1024 * 1024;
    }

    // Validate image file type
    function isImageType() {
      return request.resource.contentType.matches('image/.*');
    }

    // Validate PDF file type
    function isPDFType() {
      return request.resource.contentType == 'application/pdf';
    }

    // Validate allowed content types
    function isAllowedContentType() {
      return request.resource.contentType.matches('image/.*') ||
             request.resource.contentType == 'application/pdf' ||
             request.resource.contentType == 'application/octet-stream' ||
             request.resource.contentType.matches('application/.*');
    }

    // =========================================================================
    // ğŸ” FIRESTORE INTEGRATION HELPERS (Storage Rules v2)
    // =========================================================================
    // These helpers validate Storage writes against Firestore FileRecord documents

    // Extract fileId from fileName (format: "fileId.ext")
    // Example: "file_abc123.jpg" â†’ "file_abc123"
    function extractFileId(fileName) {
      return fileName.split('.')[0];
    }

    // Get FileRecord document path for validation
    function getFileRecordPath(fileId) {
      return /databases/(default)/documents/files/$(fileId);
    }

    // Check if FileRecord exists with status 'pending'
    // ENTERPRISE: Only allow write if pending record exists (Step A must complete before Step B)
    function hasPendingFileRecord(fileId) {
      return firestore.exists(getFileRecordPath(fileId)) &&
             firestore.get(getFileRecordPath(fileId)).data.status == 'pending';
    }

    // Validate FileRecord fields match storage path segments (WITHOUT projectId)
    // ENTERPRISE: Ensures file is uploaded to correct location
    // NOTE: For simplified path (no project), we just check core fields - projectId check removed
    // because Firestore rules don't reliably support checking for field absence
    function fileRecordMatchesPathSimple(fileId, companyId, entityType, entityId, domain, category) {
      let record = firestore.get(getFileRecordPath(fileId)).data;
      return record.companyId == companyId &&
             record.entityType == entityType &&
             record.entityId == entityId &&
             record.domain == domain &&
             record.category == category;
    }

    // Validate FileRecord fields match storage path segments (WITH projectId)
    // ğŸ¢ ENTERPRISE: STRICT path matching including projectId
    function fileRecordMatchesPathWithProject(fileId, companyId, projectId, entityType, entityId, domain, category) {
      let record = firestore.get(getFileRecordPath(fileId)).data;
      return record.companyId == companyId &&
             record.projectId == projectId &&
             record.entityType == entityType &&
             record.entityId == entityId &&
             record.domain == domain &&
             record.category == category;
    }

    // ğŸ” ENTERPRISE: Strict storagePath validation (generic)
    // Compares FileRecord.storagePath with the expected path
    // NOTE: expectedPath must be constructed at the rule level due to 7-arg limit
    function storagePathEquals(fileId, expectedPath) {
      let record = firestore.get(getFileRecordPath(fileId)).data;
      return record.storagePath == expectedPath;
    }

    // Check if FileRecord exists and storagePath matches (for delete operations)
    // ğŸ¢ ENTERPRISE: Delete requires existing FileRecord with matching storagePath
    function hasFileRecordWithPath(fileId, companyId, expectedPath) {
      return firestore.exists(getFileRecordPath(fileId)) &&
             firestore.get(getFileRecordPath(fileId)).data.companyId == companyId &&
             firestore.get(getFileRecordPath(fileId)).data.storagePath == expectedPath;
    }

    // Check if FileRecord status is 'ready' (for secure reads)
    function hasReadyFileRecord(fileId) {
      return firestore.exists(getFileRecordPath(fileId)) &&
             firestore.get(getFileRecordPath(fileId)).data.status == 'ready';
    }

    // ğŸ¢ ENTERPRISE: Ownership Principle - Creator can ALWAYS access their files
    // Pattern: SAP / Salesforce / Google Drive / Microsoft OneDrive
    // If you created it, you can read it - no claims required
    function isFileCreator(fileId) {
      return firestore.exists(getFileRecordPath(fileId)) &&
             firestore.get(getFileRecordPath(fileId)).data.createdBy == request.auth.uid;
    }

    // =========================================================================
    // ğŸ¢ CANONICAL ENTERPRISE PATH (NEW UPLOADS)
    // =========================================================================
    // Path: /companies/{companyId}/projects/{projectId}/entities/{entityType}/{entityId}/
    //       domains/{domain}/categories/{category}/files/{fileId}.{ext}
    //
    // Authorization: User must belong to company OR be super_admin
    // =========================================================================

    match /companies/{companyId}/projects/{projectId}/entities/{entityType}/{entityId}/domains/{domain}/categories/{category}/files/{fileName} {

      // ğŸ“– READ: Company-scoped access with project isolation
      // ğŸ¢ ENTERPRISE: Multi-tenant isolation by companyId + projectId
      // Security Model: Custom claims validation (companyId from auth token)
      // - Company members can read files from their company
      // - Super admins can read any file
      // NOTE: Removed Firestore lookups (isFileCreator, hasReadyFileRecord) due to
      // cross-service consistency issues causing permission failures (2026-01-20)
      allow read: if isAuthenticated() && (belongsToCompany(companyId) || isSuperAdmin());

      // âœï¸ WRITE: Company-scoped + validation
      // ğŸ¢ ENTERPRISE: Multi-tenant isolation via custom claims
      // Security Model:
      // 1. belongsToCompany() validates companyId custom claim matches path
      // 2. isSuperAdmin() allows system-wide access for admins
      // 3. File validation (size, content type)
      // NOTE: Removed Firestore lookups (hasPendingFileRecord, fileRecordMatchesPath,
      // storagePathEquals) due to unreliable cross-service consistency (2026-01-20)
      // Client-side validation in useFloorplanUpload.ts handles pre-flight checks
      allow write: if (belongsToCompany(companyId) || isSuperAdmin())
                   && isValidFileSize()
                   && isAllowedContentType();

      // ğŸ—‘ï¸ DELETE: Company-scoped access
      // ğŸ¢ ENTERPRISE: Multi-tenant isolation
      // NOTE: Removed Firestore lookup (hasFileRecordWithPath) - client handles
      // FileRecord cleanup separately from Storage deletion
      allow delete: if (belongsToCompany(companyId) || isSuperAdmin());
    }

    // =========================================================================
    // ğŸ¢ SIMPLIFIED ENTERPRISE PATH (without project scope)
    // =========================================================================
    // Path: /companies/{companyId}/entities/{entityType}/{entityId}/
    //       domains/{domain}/categories/{category}/files/{fileId}.{ext}
    //
    // For files not associated with a specific project
    // =========================================================================

    match /companies/{companyId}/entities/{entityType}/{entityId}/domains/{domain}/categories/{category}/files/{fileName} {

      // ğŸ“– READ: Company-scoped access
      // ğŸ¢ ENTERPRISE: Multi-tenant isolation by companyId
      // - Authenticated users can read files from their company
      // - Super admins can read any file
      // NOTE: Firestore-based isFileCreator() had latency issues during upload flow
      allow read: if isAuthenticated() && (belongsToCompany(companyId) || isSuperAdmin());

      // âœï¸ WRITE: Company-scoped + size validation
      // ğŸ¢ ENTERPRISE: Multi-tenant isolation
      allow write: if isAuthenticated()
                   && (belongsToCompany(companyId) || isSuperAdmin())
                   && isValidFileSize();

      // ğŸ—‘ï¸ DELETE: Company-scoped access
      allow delete: if isAuthenticated() && (belongsToCompany(companyId) || isSuperAdmin());
    }

    // =========================================================================
    // ğŸ“¸ LEGACY: CONTACT PHOTOS (Backward Compatibility)
    // =========================================================================
    // Path: /contacts/photos/{filename}
    //
    // âš ï¸ LEGACY: Will be migrated to canonical path
    // Keep for reading existing files, restrict new writes
    // =========================================================================

    match /contacts/photos/{fileName} {

      // ğŸ“– READ: Any authenticated user (for profile display)
      // TODO: Restrict to internal users after migration
      allow read: if isAuthenticated();

      // âœï¸ WRITE: Authenticated users (temporary - new uploads should use canonical)
      // Will be removed after migration
      allow write: if isAuthenticated()
                   && isValidFileSize()
                   && isImageType();

      // ğŸ—‘ï¸ DELETE: Authenticated users
      allow delete: if isAuthenticated();
    }

    // =========================================================================
    // ğŸ—ï¸ LEGACY: FLOOR PLANS (Backward Compatibility)
    // =========================================================================
    // Path: /floor-plans/{buildingId}/{floorId}/{filename}
    //
    // âš ï¸ LEGACY: Will be migrated to canonical path
    // =========================================================================

    match /floor-plans/{buildingId}/{floorId}/{fileName} {

      // ğŸ“– READ: Any authenticated user
      allow read: if isAuthenticated();

      // âœï¸ WRITE: Authenticated users (internal)
      allow write: if isAuthenticated()
                   && isValidFileSize()
                   && (isPDFType() || request.resource.contentType == 'application/octet-stream');

      // ğŸ—‘ï¸ DELETE: Authenticated users
      allow delete: if isAuthenticated();
    }

    // =========================================================================
    // ğŸ¢ LEGACY: COMPANY LOGOS
    // =========================================================================
    // Path: /companies/logos/{filename}
    // =========================================================================

    match /companies/logos/{fileName} {

      allow read: if isAuthenticated();

      allow write: if isAuthenticated()
                   && isValidFileSize()
                   && isImageType();

      allow delete: if isAuthenticated();
    }

    // =========================================================================
    // ğŸ¢ DXF SCENES (Enterprise DXF Storage)
    // =========================================================================
    // Path: /dxf-scenes/{fileId}/{filename}
    // Used by DxfFirestoreService for storing parsed DXF scene data
    // Includes: project floorplans, building floorplans, floor floorplans, unit floorplans
    // =========================================================================

    match /dxf-scenes/{fileId}/{fileName} {

      // ğŸ“– READ: Any authenticated user (internal tool)
      allow read: if isAuthenticated();

      // âœï¸ WRITE: Authenticated users (internal tool)
      allow write: if isAuthenticated()
                   && isValidFileSize();

      // ğŸ—‘ï¸ DELETE: Authenticated users
      allow delete: if isAuthenticated();
    }

    // =========================================================================
    // ğŸ¨ CAD FILES (DXF/Technical Drawings)
    // =========================================================================
    // Path: /cad/{userId}/{fileId}/{filename}
    // Ownership-based access for CAD files
    // =========================================================================

    match /cad/{userId}/{fileId}/{fileName} {

      // ğŸ“– READ: Owner or super_admin
      allow read: if isOwner(userId) || isSuperAdmin();

      // âœï¸ WRITE: Owner only
      allow write: if isOwner(userId)
                   && isValidFileSize();

      // ğŸ—‘ï¸ DELETE: Owner or super_admin
      allow delete: if isOwner(userId) || isSuperAdmin();
    }

    // =========================================================================
    // ğŸ“„ TEMPORARY UPLOADS (for processing)
    // =========================================================================
    // Path: /temp/{userId}/{filename}
    // Short-lived uploads that will be moved to canonical path
    // =========================================================================

    match /temp/{userId}/{fileName} {

      // Only owner can access their temp files
      allow read, write: if isOwner(userId)
                         && isValidFileSize();

      allow delete: if isOwner(userId);
    }

  }
}
