Το “πάλι 403” δεν είναι επειδή δεν έγινε επεξεργασία. Από τα logs φαίνεται ότι ο server:

κατέβασε το DXF, το έκανε parse,

ανέβασε το *.processed.json στο Storage,

και κατέγραψε “File made public (attempt 1)”. 

localhost-1768935250770

Παρόλα αυτά, ο client συνεχίζει να κάνει fetch(...) και παίρνει HTTP 403 όταν προσπαθεί να φορτώσει το scene: ❌ [ProjectFloorplanTab] Failed to load scene from Storage: Error: HTTP 403. 

localhost-1768935250770

Τι πάει λάθος (root cause)

Ο client φορτώνει το scene JSON με unauthenticated HTTP fetch από Storage URL. Το Firebase Storage endpoint (ή/και οι rules) δεν “βλέπουν” το Firebase Auth session όταν κάνεις απλό fetch() χωρίς Authorization: Bearer <idToken> ή χωρίς download token στο URL. Άρα το request αξιολογείται ως “ανώνυμο” και κόβεται με 403. Αυτό εξηγεί γιατί “έγινε processing” αλλά “δεν φορτώνει”.

Το makePublic() που μπήκε είναι λάθος κατεύθυνση για enterprise: (α) ανοίγει δεδομένα, (β) δεν λύνει αξιόπιστα το auth story του Firebase Storage endpoint, (γ) σε Vercel/serverless δεν θες να βασίζεσαι σε object public ACL για λειτουργικότητα.

Διόρθωση επιπέδου μεγάλης εταιρείας (canonical λύση)

Στόχος: μηδέν public αρχεία, όλα μέσω authz/tenant isolation, ίδιος τρόπος σε localhost + Vercel.

Εντολή προς Claude (να την υλοποιήσει)

Σταμάτα το “public URL + fetch” μοντέλο

Στο /api/floorplans/process:

Μην βασίζεσαι σε makePublic() για να μπορεί να φορτώσει ο client.

Αποθήκευσε στο FileRecord μόνο: processedDataPath (canonical storage path) + metadata (size, contentType, updatedAt/etag).

Κόψε/απόφυγε να γράφεις “processedDataUrl” που απαιτεί public access. 

local_3

Φτιάξε secure API για σερβίρισμα του scene JSON

Νέο endpoint π.χ. GET /api/floorplans/scene?fileId=...

Υποχρεωτικά:

Χρήση του υπάρχοντος centralized auth middleware/tenant isolation (repo-wide pre-check πριν δημιουργήσεις οτιδήποτε νέο).

Έλεγχος ότι το fileId ανήκει στο ίδιο companyId/project context του χρήστη.

Φόρτωση του JSON από Storage με Admin SDK (bucket.file(processedDataPath).download() ή stream).

Επιστροφή JSON με headers: Content-Type: application/json, Cache-Control: private, max-age=..., και ETag (π.χ. hash/updatedAt).

Client: φόρτωσε scene από το API, όχι από Storage URL

Στο ProjectFloorplanTab:

Αντί για fetch(processedDataUrl) → κάλεσε το νέο /api/floorplans/scene.

Χρησιμοποίησε το existing API client/centralized fetch wrapper (ώστε να περνά σωστά auth/observability).

Handle 404/409/202 με UX (π.χ. “processing”, retry/backoff).

Διόρθωσε το “double processing / 409” με enterprise τρόπο
Στα logs φαίνεται ότι το ίδιο file γίνεται trigger 2 φορές και παίρνεις 409 “already processing”. 

localhost-1768935250770


Το in-memory mutex δεν είναι production-safe σε Vercel (πολλαπλά instances). Άρα:

Αφαίρεσέ το και κάνε idempotency μέσω Firestore:

Transaction / conditional update στο FileRecord: status: uploaded -> processing (με processingStartedAt).

Αν είναι ήδη processing και δεν έχει λήξει TTL, μην ξανατρέχεις.

Στο τέλος: processing -> processed και γράφεις processedDataPath.

Σε crash: allow retry μετά από TTL.

Acceptance criteria (μη διαπραγματεύσιμα)

Το DXF φορτώνει σε localhost και Vercel χωρίς να γίνεται τίποτα public.

Ο client δεν κάνει άμεσο unauthenticated fetch σε Storage URLs για scene JSON.

Καμία hardcoded τιμή (TTL/max-age από centralized config/constants).

Μηδέν duplicates (repo-wide pre-check), μηδέν any, semantic structure, quality gates.

Αν ο Claude εφαρμόσει τα παραπάνω, ο 403 θα εξαφανιστεί γιατί το scene θα σερβίρεται από authenticated/authorized API αντί να “ελπίζουμε” ότι ένα Storage URL θα είναι προσβάσιμο. 

localhost-1768935250770